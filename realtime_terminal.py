#!/usr/bin/env python3
"""
AI-OS Interactive Demo Terminal
===============================

Natural real-time demo interface:
- Type any natural language prompt
- Watch APL generation in real-time
- See bytecode compilation
- Launch TUI with carbon tracking (fixed rendering)
- No pre-planned scripts - completely natural interaction

Usage: python realtime_terminal.py
"""

import sys
import json
import subprocess
import time
from pathlib import Path

# Add aiox to path
sys.path.insert(0, str(Path(__file__).parent))

from aiox.kernel.tools import ToolRegistry
from aiox.planner.core import PlanGenerator
from aiox.planner.apl_converter import APLConverter
from aiox.kernel.meters import CarbonCostMeter


def show_platform_status(registry, meter, sandbox):
    """Show current platform status"""
    tool_count = len(registry.get_all_tool_names())

    # FlightFixer tools
    ff_tools = [t for t in registry.get_all_tool_names()
               if any(w in t.lower() for w in ['flight', 'tweets', 'bts', 'parse', 'refund', 'action'])]

    # Input data
    input_files = list((sandbox / 'in').glob('*.csv'))

    # Carbon status
    historical = meter.get_historical_stats()
    totals = historical.get('totals', {})

    print(f"Platform Status:")
    print(f"  Tools: {tool_count} ({len(ff_tools)} FlightFixer)")
    print(f"  Data: {[f.name for f in input_files]}")
    if totals.get('runs_analyzed', 0) > 0:
        print(f"  Carbon: {totals.get('total_co2_grams', 0):.1f}g, ${totals.get('total_cost_usd', 0):.6f}")
    else:
        print("  Carbon: Ready for tracking")
    print()


def launch_tui_fixed(root):
    """Launch TUI with fixed rendering - direct import instead of subprocess"""
    print("Launching TUI interface...")
    print("(Press 'q' in TUI to return)")
    time.sleep(1)

    try:
        # Direct import to avoid subprocess terminal issues
        from aiox.ui.tui import main as tui_main
        tui_main(root)
        print("\nTUI closed - back to demo")

    except Exception as e:
        print(f"TUI error: {e}")
        print("Fallback: Try 'python -m aiox.ui.tui' in another terminal")
    print()


def process_natural_prompt(prompt, planner, converter, root):
    """Process natural language prompt and show results"""
    print(f"Processing: '{prompt}'")
    print("Generating workflow...")

    start_time = time.time()

    try:
        # Generate execution plan
        execution_plan = planner.generate_plan(goal=prompt)
        apl_data = converter.convert_to_apl(execution_plan)

        # Save APL
        plan_path = root / 'apps' / 'forge' / 'plan.apl.json'
        plan_path.parent.mkdir(parents=True, exist_ok=True)
        plan_path.write_text(json.dumps(apl_data, indent=2))

        generation_time = time.time() - start_time

        # Show results
        print(f"Generated: {len(execution_plan.steps)}-step workflow ({generation_time:.2f}s)")

        # Show workflow steps
        print("Workflow:")
        for i, step in enumerate(execution_plan.steps, 1):
            desc = step.description[:60] + "..." if len(step.description) > 60 else step.description
            print(f"  {i}. {step.tool}: {desc}")

        # Show planner info
        planner_type = execution_plan.metadata.get('planner_type', 'unknown')
        if planner_type == 'llm':
            print("Generated by: Claude LLM")
        else:
            print("Generated by: Fallback planner")

        return plan_path

    except Exception as e:
        print(f"Error: {e}")
        return None


def quick_compile(plan_path, root):
    """Quick compilation with user choice"""
    if not plan_path or not plan_path.exists():
        return None

    compile_choice = input("Compile to bytecode? [y/N]: ").strip().lower()
    if compile_choice != 'y':
        return None

    print("Compiling...")
    try:
        compile_result = subprocess.run([
            sys.executable, '-m', 'aiox.compiler.compile_bc',
            str(plan_path), '--tools'
        ], capture_output=True, text=True, cwd=root)

        if compile_result.returncode == 0:
            print("Compilation: SUCCESS")
            bc_path = plan_path.with_suffix('.bytecode.json')
            print(f"Bytecode: {bc_path.name}")
            return bc_path
        else:
            print("Compilation: FAILED")
            print(compile_result.stderr.strip())

    except Exception as e:
        print(f"Compile error: {e}")

    return None


def main():
    """Main interactive demo"""
    root = Path('.').resolve()
    sandbox = root / 'sandbox'

    # Initialize (quiet)
    print("AI-OS Interactive Demo")
    print("======================")
    print("Initializing...")

    registry = ToolRegistry(root / 'tools')
    tool_count = registry.discover_tools()
    planner = PlanGenerator(registry, sandbox)
    converter = APLConverter(registry)
    meter = CarbonCostMeter(sandbox)

    print(f"Ready: {tool_count} tools discovered")
    print()

    # Show status
    show_platform_status(registry, meter, sandbox)

    print("Commands:")
    print("  Type any natural language prompt (e.g., 'analyze airline complaints')")
    print("  'tui' - Launch TUI with carbon tracking")
    print("  'status' - Show platform status")
    print("  'quit' - Exit")
    print()

    # Main loop
    while True:
        try:
            prompt = input("AI-OS> ").strip()

            if not prompt:
                continue

            if prompt.lower() in ['quit', 'exit', 'q']:
                break

            if prompt.lower() == 'tui':
                launch_tui_fixed(root)
                continue

            if prompt.lower() == 'status':
                show_platform_status(registry, meter, sandbox)
                continue

            # Process natural language prompt
            print()
            plan_path = process_natural_prompt(prompt, planner, converter, root)

            if plan_path:
                print()
                bc_path = quick_compile(plan_path, root)
                if bc_path:
                    print("Ready for TUI demo (shows carbon tracking)")

            print()

        except KeyboardInterrupt:
            print("\n")
            break
        except Exception as e:
            print(f"Error: {e}")
            print()

    print("Demo complete!")


if __name__ == '__main__':
    main()